# 3.3.3 M√≥dulo Padr√µes de Projeto GoFs Comportamentais
No contexto da aplica√ß√£o A Eterna FGA, o padr√£o foi utilizado para estruturar o processo de compartilhamento de mem√≥rias em diferentes canais, como e-mail institucional, Telegram ou QR Code. O processo de compartilhamento envolve etapas comuns, como verifica√ß√£o de permiss√£o, gera√ß√£o de link e registro de log, mas varia na forma como a mensagem √© formatada e enviada, o que o torna ideal para o uso do Template Method.

Este artefato inclui diferentes implementa√ß√µes do padr√£o, cada uma respons√°vel por um canal de compartilhamento distinto. Ao final, √© apresentada uma vers√£o consolidada que re√∫ne as boas pr√°ticas observadas, com foco em clareza, reutiliza√ß√£o de c√≥digo e f√°cil extens√£o para novos formatos de compartilhamento.

## GoF FINAL

<img src="(COLOCAR IMAGEM AQUI)"/>

### Vers√µes desenvolvidas

<details>
<summary>Vers√£o do Pedro Gois:</summary>

#### Pedro
Method
```python
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum


# -------------------------
# ENUM E CLASSES DE SUPORTE
# -------------------------

class Status(Enum):
    PENDENTE = "pendente"
    APROVADA = "aprovada"
    REJEITADA = "rejeitada"


class MidiaDigital(ABC):
    @abstractmethod
    def tipo(self):
        pass


class Imagem(MidiaDigital):
    def __init__(self, caminho_arquivo):
        self.caminho_arquivo = caminho_arquivo

    def tipo(self):
        return "Imagem"


# -------------------------
# CLASSE DE MEM√ìRIA
# -------------------------

class Memoria:
    def __init__(self, descricao, midia, data_envio, status):
        self.descricao = descricao
        self.midia = midia
        self.data_envio = data_envio
        self.status = status

    def __str__(self):
        return (f"Mem√≥ria enviada em {self.data_envio.strftime('%d/%m/%Y %H:%M:%S')}, "
                f"status: {self.status.name}, descri√ß√£o: {self.descricao}, "
                f"m√≠dia: {self.midia.tipo()}")


# -------------------------
# TEMPLATE METHOD: Compartilhador
# -------------------------

class CompartilhadorMemoria(ABC):
    def compartilhar(self, memoria: Memoria):
        self.validar_memoria(memoria)
        url = self.gerar_url(memoria)
        return self.formatar_link(url)

    def validar_memoria(self, memoria):
        if memoria.status != Status.APROVADA:
            raise ValueError("‚ö†Ô∏è S√≥ √© poss√≠vel compartilhar mem√≥rias que foram aprovadas.")

    def gerar_url(self, memoria):
        # Em um sistema real, voc√™ teria uma URL com slug ou ID real.
        return f"https://meusite.com/memorias/{id(memoria)}"

    @abstractmethod
    def formatar_link(self, url: str):
        pass


# -------------------------
# IMPLEMENTA√á√ïES CONCRETAS
# -------------------------

class CompartilhadorWhatsApp(CompartilhadorMemoria):
    def formatar_link(self, url):
        texto = f"Veja essa mem√≥ria incr√≠vel: {url}"
        return f"https://wa.me/?text={texto.replace(' ', '%20')}"


class CompartilhadorEmail(CompartilhadorMemoria):
    def formatar_link(self, url):
        assunto = "Mem√≥ria Compartilhada"
        corpo = f"Veja essa mem√≥ria: {url}"
        return f"mailto:?subject={assunto.replace(' ', '%20')}&body={corpo.replace(' ', '%20')}"


class CompartilhadorLinkDireto(CompartilhadorMemoria):
    def formatar_link(self, url):
        return url


# -------------------------
# USO DO TEMPLATE METHOD
# -------------------------

if __name__ == "__main__":
    # Cria√ß√£o de uma mem√≥ria aprovada
    memoria = Memoria(
        descricao="Foto da formatura com os amigos",
        midia=Imagem("formatura.jpg"),
        data_envio=datetime.now(),
        status=Status.APROVADA
    )

    # Lista de canais de compartilhamento
    compartilhadores = [
        CompartilhadorWhatsApp(),
        CompartilhadorEmail(),
        CompartilhadorLinkDireto()
    ]

    print(f"\nüéì Compartilhando: {memoria.descricao}\n")

    for compartilhador in compartilhadores:
        nome_canal = compartilhador.__class__.__name__.replace("Compartilhador", "")
        link = compartilhador.compartilhar(memoria)
        print(f"{nome_canal}: {link}")
```

</details>

<details>
<summary>Vers√£o do Cairo Floren√ßo:</summary>

```python

```

</details>

<details>
<summary>Vers√£o do Gabriel:</summary>

```python
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import List


# ------------------------
# ENUMS E CLASSES DE SUPORTE
# ------------------------

class StatusMemoria(Enum):
    PENDENTE = "pendente"
    ACEITA = "aceita"
    RECUSADA = "recusada"

class Midia:
    def __init__(self, tipo: str, caminho: str):
        self.tipo = tipo
        self.caminho = caminho

class Memoria:
    def __init__(
        self,
        titulo: str,
        midias: List[Midia],
        descricao: str,
        autor: str,
        status: StatusMemoria,
        data_envio: datetime,
    ):
        self.titulo = titulo
        self.midias = midias
        self.descricao = descricao
        self.autor = autor
        self.status = status
        self.data_envio = data_envio


# ------------------------
# TEMPLATE METHOD
# ------------------------

class CompartilhamentoMemoria(ABC):
    def compartilhar(self, memoria: Memoria) -> str:
        if memoria.status != StatusMemoria.ACEITA:
            raise PermissionError("‚ö†Ô∏è Apenas mem√≥rias aceitas podem ser compartilhadas.")
        print(f"[LOG] {memoria.autor} tentou compartilhar em {datetime.utcnow().isoformat()}")
        url = f"https://eternafga.unb.br/memoria/{memoria.titulo.lower().replace(' ', '-')}-{id(memoria)}"
        return self.encaminhar(memoria, self.formatar_mensagem(memoria, url))

    @abstractmethod
    def formatar_mensagem(self, memoria: Memoria, url: str) -> str:
        pass

    @abstractmethod
    def encaminhar(self, memoria: Memoria, mensagem: str) -> str:
        pass


# ------------------------
# IMPLEMENTA√á√ïES CONCRETAS
# ------------------------

class CompartilhadorEmailFGA(CompartilhamentoMemoria):
    def formatar_mensagem(self, memoria, url):
        return f"{memoria.autor} compartilhou uma mem√≥ria:\n{memoria.titulo}\n{memoria.descricao}\n{url}"

    def encaminhar(self, memoria, mensagem):
        return f"üìß Enviado via email institucional:\n{mensagem}"

class CompartilhadorTelegram(CompartilhamentoMemoria):
    def formatar_mensagem(self, memoria, url):
        return f"üì® Telegram: {memoria.titulo}\n{url}"

    def encaminhar(self, memoria, mensagem):
        return f"üì® Telegram enviado: {mensagem}"

class CompartilhadorQRCode(CompartilhamentoMemoria):
    def formatar_mensagem(self, memoria, url):
        return f"{url} (QR gerado)"

    def encaminhar(self, memoria, mensagem):
        return f"[QR] C√≥digo gerado: {mensagem}"


# ------------------------
# EXEMPLO DE USO
# ------------------------

if __name__ == "__main__":
    memoria = Memoria(
        titulo="Apresenta√ß√£o Final de Projeto",
        midias=[Midia("imagem", "http://site/imgs/projeto.png")],
        descricao="Uma jornada desafiadora e gratificante.",
        autor="Marina Lima",
        status=StatusMemoria.ACEITA,
        data_envio=datetime.now()
    )

    compartilhadores = [
        CompartilhadorEmailFGA(),
        CompartilhadorTelegram(),
        CompartilhadorQRCode()
    ]

    print(f"\nüì§ Compartilhando: {memoria.titulo}\n")

    for c in compartilhadores:
        nome = c.__class__.__name__.replace("Compartilhador", "")
        try:
            print(f"{nome}: {c.compartilhar(memoria)}")
        except Exception as e:
            print(f"{nome}: ERRO - {e}")

```

</details>


</details>



## Hist√≥rico de Vers√£o

| Vers√£o | Data | Descri√ß√£o | Autor(es) | Revisor(es) | Coment√°rio do Revisor |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 1.0 | 22/05 | Primeira vers√£o do GoF | Pedro Gois | Pedro Gois | - |
| 1.1 | 30/05 | segunda vers√£o do GoF | Pedro Gois | Pedro Gois | - |
| 1.2 | 30/05 | Primeira vers√£o do GoF e adi√ß√£o da introdu√ß√£o ao artefato | Gabriel Scheidt | - | - |
