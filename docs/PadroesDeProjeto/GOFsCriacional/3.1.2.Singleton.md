# Singleton

## GoF FINAL

<img src="(COLOCAR IMAGEM AQUI)"/>

### Versões desenvolvidas

<details>
<summary>Versões desenvolvidas por integrante:</summary>

<details>
<summary>Versão do Gustavo:</summary>

### Gustavo

A implementação foi desenvolvida com base no exemplo disponibilizado pela professora no Aprender3 e, também baseado no site refactoring guru, adaptando-o para os nossos componentes.  

### Modelagem

![Modelagem do Singleton - Autenticador](../../assets/GOFsCriacionais/Singleton/SingletonGustavo.png)

<center>

Autor: [Gustavo Feitosa Haubert](https://github.com/GustavoHaubert)

</center>

### Código

```python
from datetime import datetime, timedelta
from typing import Optional, List

class Sessao:
    def __init__(self, token: str, usuario: str, duracao_minutos: int = 30):
        self.token = token
        self.usuario = usuario
        self.createdAt = datetime.now()
        self.expiresAt = self.createdAt + timedelta(minutes=duracao_minutos)
        self.ativa = True

    def reiniciarSessao(self):
        self.createdAt = datetime.now()
        self.expiresAt = self.createdAt + timedelta(minutes=30)
        self.ativa = True

    def iniciarSessao(self):
        self.createdAt = datetime.now()
        self.expiresAt = self.createdAt + timedelta(minutes=30)
        self.ativa = True

    def is_valida(self) -> bool:
        return self.ativa and datetime.now() < self.expiresAt

    def encerrarSessao(self):
        self.ativa = False


# --- Singleton ---
class Autenticador:
    __instancia = None

    def __init__(self):
        if Autenticador.__instancia is not None:
            raise Exception("Esta classe é um singleton! Use get_instancia().")
        self.sessoesAtivas: List[Sessao] = []

    @staticmethod
    def get_instancia():
        if Autenticador.__instancia is None:
            Autenticador.__instancia = Autenticador()
        return Autenticador.__instancia

    def autenticarUsuario(self, login: str, senha: str) -> Optional[str]:
        if login == "admin" and senha == "123":
            token = f"TOKEN-{login}-{datetime.now().timestamp()}"
            nova_sessao = Sessao(token, login)
            self.sessoesAtivas.append(nova_sessao)
            return token
        return None

    def terminarSessao(self, login: str):
        for sessao in self.sessoesAtivas:
            if sessao.usuario == login:
                sessao.encerrarSessao()

    def getUsuarioLogado(self, login: str) -> Optional[str]:
        for sessao in self.sessoesAtivas:
            if sessao.usuario == login and sessao.is_valida():
                return login
        return None

    def validateToken(self, token: str) -> bool:
        for sessao in self.sessoesAtivas:
            if sessao.token == token and sessao.is_valida():
                return True
        return False

```

<center>

Autor: [Gustavo Feitosa Haubert](https://github.com/GustavoHaubert)

</center>

</details>

<details>
<summary>Versão da Maria Eduarda:</summary>

## Introdução

O padrão de projeto **Singleton** é um dos padrões criacionais mais utilizados em Engenharia de Software. Seu objetivo é garantir que uma determinada classe tenha **apenas uma única instância** durante todo o ciclo de vida da aplicação. Além disso, ele fornece um **ponto de acesso global** a essa instância.

Este padrão é útil, por exemplo, quando precisamos de um objeto central que gerencia algo único, como:

- Conexão com banco de dados
- Configurações da aplicação
- Sistemas de autenticação (como no nosso caso)

##  Contexto

Neste exemplo, implementamos o padrão Singleton em uma classe chamada `Autenticador`, que é responsável por autenticar usuários e armazenar o usuário atualmente logado.

Mesmo que a aplicação tente criar várias instâncias do `Autenticador`, o Singleton garante que **todas as referências apontem para a mesma instância**. Com o padrão Singleton aplicado, garantimos que a classe Autenticador seja uma única fonte de verdade para o controle de autenticação no sistema. Isso previne comportamentos inconsistentes e facilita a manutenção da lógica de login.

##  Lógica do Singleton

Em Python, a implementação do Singleton é feita sobrescrevendo o método especial `__new__`, que é chamado antes do `__init__`, sempre que uma nova instância da classe é criada.

A lógica é:

1. Verifica se a instância já existe.
2. Se não existir, cria uma nova instância e armazena em um atributo de classe.
3. Retorna sempre a mesma instância em chamadas subsequentes.

![Modelagem do Singleton - Autenticador](../../assets/GOFsCriacionais/Singleton/SingletonDuda.png)

<center>

Autor: [Maria Eduarda Vieira ](https://github.com/DudaV228)

</center>

### Código
```python

class Autenticador:
    _instancia = None

    def __new__(cls):
        if cls._instancia is None:
            cls._instancia = super(Autenticador, cls).__new__(cls)
            cls._instancia._usuario_logado = None
        return cls._instancia

    def autenticar(self, usuario, senha):
        if usuario == "admin" and senha == "1234":
            self._usuario_logado = usuario
            return True
        return False

    def get_usuario_logado(self):
        return self._usuario_logado

    def logout(self):
        self._usuario_logado = None

```

<center>

Autor: [Maria Eduarda Vieira ](https://github.com/DudaV228)

</center>
</details>


</details>



## Referências Bibliográficas



## Histórico de Versão

| Versão |  Data  | Descrição | Autor(es) | Revisor(es) | Comentário do Revisor |
| :-: | :-: | :-: | :-: | :-: | :-: |
|   1.0  |  30/05 | adicionando versão individual da implementação do Singleton     | Gustavo |  |  |
|   2.0  |  01/06 | adicionando versão individual da implementação do Singleton     | Maria Eduarda |  |  |